[
  {
    "prompt": "Generate Python code that uses Open3D to create multiple 3D shapes including a cube, a sphere, and a cylinder. The code should compute vertex normals for each shape to ensure proper shading, translate the shapes so they do not overlap, and finally export the rendered scene as a PNG image to the /output folder without launching an interactive window.",
    "code": "import open3d as o3d\nimport numpy as np\nimport os\nfrom export_mesh import export_mesh  # Import the export_mesh function from your module\n\n# Create a cube (box)\ncube = o3d.geometry.TriangleMesh.create_box(width=1.0, height=1.0, depth=1.0)\ncube.compute_vertex_normals()\n\n# Create a sphere\nsphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.5)\nsphere.compute_vertex_normals()\n\n# Create a cylinder\ncylinder = o3d.geometry.TriangleMesh.create_cylinder(radius=0.3, height=1.0)\ncylinder.compute_vertex_normals()\n\n# Translate shapes to avoid overlap\ncube.translate(np.array([-1.5, 0, 0]))\nsphere.translate(np.array([1.5, 0, 0]))\ncylinder.translate(np.array([0, 1.5, 0]))\n\n# Function to merge multiple meshes into one\ndef merge_meshes(meshes):\n    merged_mesh = o3d.geometry.TriangleMesh()\n    vertices = []\n    triangles = []\n    offset = 0\n    for mesh in meshes:\n        v = np.asarray(mesh.vertices)\n        t = np.asarray(mesh.triangles)\n        vertices.append(v)\n        triangles.append(t + offset)\n        offset += v.shape[0]\n    merged_mesh.vertices = o3d.utility.Vector3dVector(np.vstack(vertices))\n    merged_mesh.triangles = o3d.utility.Vector3iVector(np.vstack(triangles))\n    merged_mesh.compute_vertex_normals()\n    return merged_mesh\n\n# Merge the individual meshes\nmerged = merge_meshes([cube, sphere, cylinder])\n\n# Define the output folder and file name\noutput_folder = \"./output\"\nfile_name = \"merged_mesh.ply\"\n\n# Use the export_mesh function from export_mesh.py to save the mesh\nexport_mesh(merged, output_folder, file_name)\n"
  },
  {
    "prompt": "Generate Open3D code to generate a red cube",
    "code": "import open3d as o3d\nimport os\nfrom export_mesh import export_mesh  # Ensure export_mesh.py is in the same directory\n\n# Create a cube (box)\nred_cube = o3d.geometry.TriangleMesh.create_box(width=1.0, height=1.0, depth=1.0)\nred_cube.compute_vertex_normals()\n\n# Paint the cube red (RGB: 1, 0, 0)\nred_cube.paint_uniform_color([1.0, 0.0, 0.0])\n\n# Define the output folder and file name\noutput_folder = \"./output\"\nfile_name = \"red_cube.ply\"\n\n# Export the red cube using the export_mesh function\nexport_mesh(red_cube, output_folder, file_name)\n"
  },

  {
    "prompt": "Generate Python code that uses Open3D to create a point cloud representation of a torus. The torus should be generated by sampling points using the torus parametric equations, and the resulting point cloud should be displayed with Open3D's visualization tools",
    "code": "import open3d as o3d\nimport numpy as np\nfrom export_mesh import export_mesh  # Ensure export_mesh.py is in the same directory\n\n# Torus parameters\nR = 2.0   # Major radius: distance from the center of the tube to the center of the torus\nr = 0.5   # Minor radius: radius of the tube\nnum_points = 5000  # Number of points to sample\n\n# Generate parameters uniformly\nu = np.random.uniform(0, 2 * np.pi, num_points)\nv = np.random.uniform(0, 2 * np.pi, num_points)\n\n# Parametric equations for a torus\nx = (R + r * np.cos(v)) * np.cos(u)\ny = (R + r * np.cos(v)) * np.sin(u)\nz = r * np.sin(v)\n\n# Stack into a (N,3) array\npoints = np.vstack((x, y, z)).T\n\n# Create the Open3D PointCloud and assign points\ntorus_pcd = o3d.geometry.PointCloud()\ntorus_pcd.points = o3d.utility.Vector3dVector(points)\n\n# Optionally, paint the point cloud (e.g., green)\ntorus_pcd.paint_uniform_color([0.0, 1.0, 0.0])\n\n# Define output folder and file name\noutput_folder = \"./output\"\nfile_name = \"torus_point_cloud.ply\"\n\n# Export the point cloud using the dedicated function\nexport_mesh(torus_pcd, output_folder, file_name)\n"
  }
]
